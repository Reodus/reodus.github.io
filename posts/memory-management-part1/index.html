<!DOCTYPE html>
<html lang="en-us"><head><meta charset="utf-8">
<meta http-equiv="content-type" content="text/html">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title itemprop="name">Memory Management - Part 1: Virtual memory and Paging concepts | Reodus</title>
<meta property="og:title" content="Memory Management - Part 1: Virtual memory and Paging concepts | Reodus" />
<meta name="twitter:title" content="Memory Management - Part 1: Virtual memory and Paging concepts | Reodus" />
<meta itemprop="name" content="Memory Management - Part 1: Virtual memory and Paging concepts | Reodus" />
<meta name="application-name" content="Memory Management - Part 1: Virtual memory and Paging concepts | Reodus" />
<meta property="og:site_name" content="Reodus" />

<meta name="description" content="An Introduction to Virtual memory and Paging in the Intel Architecture">
<meta itemprop="description" content="An Introduction to Virtual memory and Paging in the Intel Architecture" />
<meta property="og:description" content="An Introduction to Virtual memory and Paging in the Intel Architecture" />
<meta name="twitter:description" content="An Introduction to Virtual memory and Paging in the Intel Architecture" />

<meta property="og:locale" content="en-us" />
<meta name="language" content="en-us" />



  <meta itemprop="image" content="https://reodus.com/" />
  <meta property="og:image" content="https://reodus.com/" />
  <meta name="twitter:image" content="https://reodus.com/" />
  <meta name="twitter:image:src" content="https://reodus.com/" />




    
    
    
    

    <meta property="og:type" content="article" />
    <meta property="og:article:published_time" content=2024-10-21T00:00:00Z />
    <meta property="article:published_time" content=2024-10-21T00:00:00Z />

    
    <meta property="og:article:author" content="Amir m. jahangirzad" />
    <meta property="article:author" content="Amir m. jahangirzad" />
    <meta name="author" content="Amir m. jahangirzad" />
    

    

    <script defer type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "Article",
        "headline": "Memory Management - Part 1: Virtual memory and Paging concepts",
        "author": {
        "@type": "Person",
        "name": ""
        },
        "datePublished": "2024-10-21",
        "description": "An Introduction to Virtual memory and Paging in the Intel Architecture",
        "wordCount":  3394 ,
        "mainEntityOfPage": "True",
        "dateModified": "2024-10-21",
        "image": {
        "@type": "imageObject",
        "url": ""
        },
        "publisher": {
        "@type": "Organization",
        "name": "Reodus"
        }
    }
    </script>


<meta name="generator" content="Hugo 0.122.0">

    

    <link rel="canonical" href="https://reodus.com/posts/memory-management-part1/">
    <link href="/style.min.d43bc6c79baa87f006efb2b92be952faeedeb1a3ab626c1d6abda52eae049355.css" rel="stylesheet">
    <link href="/code-highlight.min.9d9971b4b569835865e5617a058c37b759289ce4de19430938e8f1157f91ea05.css" rel="stylesheet">

    
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg">
    <link rel="shortcut icon" href="/favicon.ico">




<link rel="manifest" href="https://reodus.com/site.webmanifest">

<meta name="msapplication-config" content="/browserconfig.xml">
<meta name="msapplication-TileColor" content="#2d89ef">
<meta name="theme-color" content="#434648">

    
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">

    
    </head>
<body data-theme = "light" class="notransition">

<script src="/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js" integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script>

<div class="navbar" role="navigation">
    <nav class="menu" aria-label="Main Navigation">
        <a href="https://reodus.com/" class="logo">
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" 
viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" 
stroke-linejoin="round" class="feather feather-home">
<title>Home</title>
<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
<polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg>
        </a>
        <input type="checkbox" id="menu-trigger" class="menu-trigger" />
        <label for="menu-trigger">
            <span class="menu-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentColor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7L3.40726 7"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488L3.49301 3.51488"></path><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"></path><path stroke-linecap="round" stroke-linejoin="round" d="M0.5 12.5V1.5C0.5 0.947715 0.947715 0.5 1.5 0.5H12.5C13.0523 0.5 13.5 0.947715 13.5 1.5V12.5C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C0.947715 13.5 0.5 13.0523 0.5 12.5Z"></path></svg>
            </span>
        </label>

        <div class="trigger">
            <ul class="trigger-container">
                
                
                <li>
                    <a class="menu-link " href="/">
                        Home
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link active" href="/posts/">
                        Posts
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/pages/about/">
                        About
                    </a>
                    
                </li>
                
                <li>
                    <a class="menu-link " href="/categories/">
                        Categories
                    </a>
                    
                </li>
                
                <li class="menu-separator">
                    <span>|</span>
                </li>
                
                
            </ul>
            <a id="mode" href="#">
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1">
<title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></circle><line x1="7" y1="0.5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="0.5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"></line><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"></line></g></svg>
            </a>
        </div>
    </nav>
</div>

<div class="wrapper post">
    <main class="page-content" aria-label="Content">
        <article>
            <header class="header">
                <h1 class="header-title">Memory Management - Part 1: Virtual memory and Paging concepts</h1>
                
                
                <div class="post-meta">
                    <time datetime="2024-10-21T00:00:00&#43;00:00" itemprop="datePublished"> Oct 21, 2024 </time>
                </div>
                
            </header>
            
    
    <details class="toc" ZgotmplZ>
        <summary><b>Table of Contents</b></summary>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#virtual-memory">Virtual Memory</a></li>
    <li><a href="#page-sizes-in-virtual-memory">Page Sizes in Virtual Memory</a></li>
    <li><a href="#memory-page-states">Memory Page States</a></li>
    <li><a href="#guard-pages">Guard Pages</a>
      <ul>
        <li><a href="#windows-vmmap-example">Windows VMMap Example</a></li>
      </ul>
    </li>
    <li><a href="#page-table-hierarchy-and-address-translation">Page Table Hierarchy and Address Translation</a>
      <ul>
        <li><a href="#whats-the-use-of-page-levels">What&rsquo;s the use of page levels?</a></li>
      </ul>
    </li>
    <li><a href="#page-levels-in-the-intel-x86-64-architecture">Page Levels in the Intel x86-64 Architecture</a>
      <ul>
        <li>
          <ul>
            <li><a href="#pml4">PML4</a></li>
            <li><a href="#pdpt">PDPT</a></li>
            <li><a href="#pdt">PDT</a></li>
            <li><a href="#pt">PT</a></li>
          </ul>
        </li>
        <li><a href="#example-translating-a-64-bit-virtual-address">Example: Translating a 64-bit Virtual Address</a></li>
      </ul>
    </li>
    <li><a href="#control-registers-for-paging">Control Registers for Paging</a>
      <ul>
        <li><a href="#cr0-register">CR0 Register</a></li>
        <li><a href="#cr2-register">CR2 Register</a></li>
        <li><a href="#cr3-register">CR3 Register</a></li>
        <li><a href="#cr4-register">CR4 Register</a></li>
      </ul>
    </li>
    <li><a href="#example-1-examining-virtual-and-physical-memory-using-windbg">Example 1: Examining virtual and physical memory using Windbg</a>
      <ul>
        <li>
          <ul>
            <li><a href="#step-1-get-the-list-of-processes">Step 1: Get the List of Processes</a></li>
            <li><a href="#step-2-change-context-to-a-specific-process">Step 2: Change Context to a Specific Process</a></li>
            <li><a href="#step-3-find-virtual-address-descriptors-vad">Step 3: Find Virtual Address Descriptors (VAD)</a></li>
            <li><a href="#step-4-retrieve-page-table-entry-pte">Step 4: Retrieve Page Table Entry (PTE)</a></li>
            <li><a href="#step-5-determine-plm4-and-cr3-values">Step 5: Determine PLM4 and CR3 Values</a></li>
            <li><a href="#step-6-convert-virtual-address-to-physical-address">Step 6: Convert Virtual Address to Physical Address</a></li>
            <li><a href="#step-7-verify-using-physical-and-virtual-dump-commands">Step 7: Verify Using Physical and Virtual Dump Commands</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#example-2-finding-the-physical-address-of-a-page-using-the-pfn-formula-in-windows">Example 2: Finding the Physical Address of a Page Using the PFN Formula in Windows</a></li>
  </ul>
</nav>
    </details>
            <div class="page-content">
                <p>Memory is an important part of a computer system that is used to store data. The process of memory management is critical because there is a limited amount of memory available to a computer system. One of the most important parts in the kernel of an operating system is the memory management part. In this section, the kernel has the task of making the memory available to the executive units (like processes or threads) by effectively communicating with the <strong>memory management unit</strong> in the processor, or in other words, allocating the memory to them.</p>
<h2 id="virtual-memory">Virtual Memory</h2>
<p>Virtual memory is one of the memory management techniques in the operating system. Using this technique for memory management in operating systems makes the processes have the illusion that they have a very large space of memory at their disposal, when the main memory space can be much more limited. In this model, the operating system divides the virtual memory into smaller pieces called pages. The reason for this segmentation is to simplify the process of accessing different memory locations. Each of these pages can be considered equivalent to a location in main memory or secondary memory. This means that some memory pages of a process can be stored in RAM while others can be stored on disk. Figure 1 shows an abstract of this topic.</p>
<table>
<thead>
<tr>
<th><center> <img src="MemoryPages.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 1: Abstraction of process pages and their mapped locations in main memory and secondary memory</b></center></td>
</tr>
</tbody>
</table>
<p>This approach offers two main benefits:</p>
<ol>
<li><strong>Isolation</strong>: Each process operates within its own virtual address space, isolating it from other processes. This prevents one process from accessing or modifying the memory of another process unless explicitly permitted, enhancing security and stability.</li>
<li><strong>Efficiency</strong>: The operating system loads only the parts of a process&rsquo;s memory that are actively being used into RAM, leaving less frequently used parts on disk. This optimizes the use of physical memory and ensures that more memory is available for other tasks.</li>
</ol>
<h2 id="page-sizes-in-virtual-memory">Page Sizes in Virtual Memory</h2>
<p>Modern operating systems use different <strong>page sizes</strong> to balance performance and flexibility. The size of a page impacts how memory is allocated and managed. For example, There are three common page sizes on <strong>Intel’s 64-bit architecture</strong>,</p>
<ol>
<li><strong>Standard/Small Pages (4 KB)</strong>: In Intel&rsquo;s 64-bit architecture, the size of these pages is 4 kilobytes. These types of pages are most commonly used in virtual memory systems and are used as the basic unit of pages for most processes. The small size of these pages allows the operating system to manage memory accurately and optimally. Using this type of pages for programs that require a large amount of memory reduces system efficiency.</li>
<li><strong>Large Pages (2 MB)</strong>: The size of these pages is 2 MB. These pages are usually suitable for programs that need to access large chunks of memory. Due to the larger size, fewer page tables are used for mapping, which reduces the operating system&rsquo;s memory management burden. However, it should be noted that using larger pages reduces the flexibility of the operating system in memory management, because smaller parts of memory cannot be controlled accurately.</li>
<li><strong>Huge Pages (1 GB)</strong>: the size of these pages is equal to 1 GB. Very large pages are used for applications that require access to very large volumes of data and are typically used in server systems or high-performance computing environments. By using huge pages, the need for a large number of page tables is eliminated, which reduces the operating system&rsquo;s burden of memory management. Hence, it is suitable for extremely large applications such as very large databases, virtual machine disks and big data analysis. Also, for the same reason as the previous type, these pages are not flexible and are used only in special cases. The table below shows the size of pages in different architectures.</li>
</ol>
<table>
<thead>
<tr>
<th>Architecture</th>
<th>Small Pages</th>
<th>Large Pages</th>
<th>Huge Pages</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86-32</td>
<td>4 KB</td>
<td>2 MB</td>
<td>1 GB</td>
</tr>
<tr>
<td>x86-64</td>
<td>4 KB</td>
<td>2 MB</td>
<td>1 GB</td>
</tr>
<tr>
<td>ARM</td>
<td>4 KB</td>
<td>4 MB</td>
<td>-</td>
</tr>
<tr>
<td>ARM64</td>
<td>4 KB</td>
<td>2 MB</td>
<td>512 MB</td>
</tr>
</tbody>
</table>
<h2 id="memory-page-states">Memory Page States</h2>
<p>In addition to different sizes, memory pages can exist in various <strong>states</strong> within the system. These states determine how the pages are used and whether they are available for allocation:</p>
<ol>
<li><strong>Committed Pages</strong>: The Committed virtual memory pages are pages that are mapped to a frame in physical memory. These pages are available for use by the application and data is stored and processed in it. When an executive unit requests memory from the kernel, the operating system commits the memory for those pages so that the executive unit can use those pages to store and reuse its data.</li>
<li><strong>Reserved Pages</strong>: The Reserved pages occupy part of the virtual address space, but are not yet mapped to physical memory or paging space. These pages are reserved for future use, but are not committed until the application asks the operating system to use them. This helps to keep the address space available to the application without using physical memory unnecessarily. If the program uses these pages without requesting them to be committed, the operating system will close the process by sending a page fault exception error.</li>
<li><strong>Free Pages</strong>: The Free pages are actually free and are not assigned to any process. These pages are available to be allocated to applications by the operating system as needed. When an application requests memory, free pages can be reserved first and then committed as needed. As with the previous type, any access to these pages without reservation and commit requests will result in memory page fault.</li>
</ol>
<p>By managing these page states, the operating system ensures that memory is allocated efficiently, reusing and swapping pages between RAM and disk when necessary.</p>
<h2 id="guard-pages">Guard Pages</h2>
<p>Guard pages are a specialized type of virtual memory page used to protect memory regions and manage dynamic memory growth. They are marked with a special protection mask that triggers an exception (STATUS_GUARD_PAGE_VIOLATION) when accessed, signaling that the boundary of committed memory has been reached.</p>
<p>This exception can be handled by the program using a try/except block, allowing it to take action such as committing more memory. Once the guard page is accessed and the exception is handled, the system typically commits more memory to meet the program’s needs, and the previously protected guard page becomes part of the committed memory. A new guard page is then set at the next boundary to continue the protection.</p>
<p>Guard pages are commonly used for managing stack growth in programs. A stack can reserve more memory than is immediately needed, committing additional pages dynamically as the program requires them, with guard pages ensuring that memory overruns are caught safely.</p>
<p>Reserved memory for guard pages has a minimal impact on system resources, as the memory is only committed when it is accessed, ensuring efficient resource usage.</p>
<h3 id="windows-vmmap-example">Windows VMMap Example</h3>
<p>Figure 2 in the article shows a screenshot from VMMap, a Windows tool for visualizing memory usage, highlighting how guard pages are visually distinct from other memory types and are used to manage the growth of memory regions dynamically.</p>
<table>
<thead>
<tr>
<th><center> <img src="PageGuard-VMMAP.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 2: Display of pages and guard page mechanism in VMMAP software of Windows operating system</b></center></td>
</tr>
</tbody>
</table>
<h2 id="page-table-hierarchy-and-address-translation">Page Table Hierarchy and Address Translation</h2>
<p>In general, in virtual memory technique, there are two types of addressing methods called <strong>virtual/logical address</strong> and <strong>physical address</strong>. The virtual address belongs to the virtual space of the memory that is dedicated to the processes, and the physical address is the exact location of the desired data in the physical memory. Although the process of allocating memory, creating and managing pages is the responsibility of the operating system, the task of translating the virtual address to the physical address is the responsibility of a hardware part called <strong>Memory Management Unit (MMU)</strong>. The work of this hardware is address translation, access control and cache control. In the address translation section, the operating system can access the location of the physical address by giving the virtual address to the MMU and can perform its desired actions. Figure 3 shows the form in which the MMU is considered a separate hardware unit and the processor uses it to access the memory.</p>
<table>
<thead>
<tr>
<th><img src="MMU.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 3: Abstraction of an old architecture for communication between MMU and addresses </b></center></td>
</tr>
</tbody>
</table>
<p>In the x86-64 architecture, while the virtual address is theoretically 64-bits, only the lower 48 bits are used bacause of limitations in current implementations. This means that 256 TB of virtual memory is addressable and accessible (That&rsquo;s why there&rsquo;s a free gap between user-space and kernel-space). The virtual address is translated in 5 different levels in the page tables, but the Windows operating system supports only 4 levels, which we will examine only those four levels below.</p>
<h3 id="whats-the-use-of-page-levels">What&rsquo;s the use of page levels?</h3>
<p>Systems with a large address space, such as x86-64, need solutions to manage all virtual memory space optimally. Dividing this space into different levels means that large parts of the memory that are not used do not need to be mapped directly and only a part of the addressing space is managed dynamically.</p>
<h2 id="page-levels-in-the-intel-x86-64-architecture">Page Levels in the Intel x86-64 Architecture</h2>
<p>As mentioned, 4 different levels for memory pages in the Windows operating system can be considered, which are:</p>
<ol>
<li><strong>Page Map Level 4 (PML4)</strong></li>
<li><strong>Page Directory Pointer Table (PDPT)</strong></li>
<li><strong>Page Directory Table (PDT)</strong></li>
<li><strong>Page Table (PT)</strong></li>
</ol>
<h4 id="pml4">PML4</h4>
<p>This table is the first level of page table of x86-64 systems, which has 512 entries and each entry can point to a PDP table on the second level. In fact, PML4 manages the overall map of access to larger parts of memory. The main use of this level is to divide a very large address space into smaller parts, and there is no need for the operating system to manage the entire space directly. Each entry in PML4 covers about 512 GB of virtual address space.</p>
<h4 id="pdpt">PDPT</h4>
<p>PDPT is the second level of the page table and each entry from this level points to a PD table. The PDP table also has 512 entries and each entry can manage 1 GB of virtual space. If Huge pages are used, this level can directly point to physical addresses without the need for lower levels, and in this case, each entry in the PDP table can handle a 1 GB page.</p>
<h4 id="pdt">PDT</h4>
<p>The third level of the PDT page table has 512 entries like the previous levels. Each entry in the PD table can handle 2 MB of virtual addressing space. Also, each entry points to a PT. If large 2MB pages are used, the PD table can point directly to physical addresses and there is no need for a PT level. In this case, the translation process becomes faster and simpler because fewer levels are required for translation.</p>
<h4 id="pt">PT</h4>
<p>This level is the last level of the page table where each entry points to a 4 KB page of physical memory. PT also has 512 entries, and each entry points to a 4KB physical frame. This hierarchical structure efficiently manages large virtual memory spaces and reduces the complexity of maintaining large page tables.</p>
<table>
<thead>
<tr>
<th><img src="Paging-Levels.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 4: Paging Levels from AMD Architecture programmer&rsquo;s manual, volume 2</b></center></td>
</tr>
</tbody>
</table>
<hr>
<p>The virtual address is divided into 5 parts and each part is used to index into a different level of the page table hierarchy. For example, in x86-64 systems, the <strong>address translation</strong> process in paging level works as follows:</p>
<ul>
<li><strong>Bits 47-39</strong>: Used to index into the PML4.</li>
<li><strong>Bits 38-30</strong>: Used to index into the PDPT.</li>
<li><strong>Bits 29-21</strong>: Used to index into the PDT.</li>
<li><strong>Bits 20-12</strong>: Used to index into the PT.</li>
<li><strong>Bits 11-0</strong>: Represent the offset within the 4 KB page.</li>
</ul>
<h3 id="example-translating-a-64-bit-virtual-address">Example: Translating a 64-bit Virtual Address</h3>
<p>Consider a 64-bit virtual address like <code>0x00007FFFFFFFFFFF</code>. This address is divided into segments, with each segment used to index into a different level of the page table hierarchy. The breakdown is as follows:</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Binary Value</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>PML4</td>
<td><code>000000000</code></td>
<td>Index into the PML4 table</td>
</tr>
<tr>
<td>PDPT</td>
<td><code>111111111</code></td>
<td>Index into the PDPT</td>
</tr>
<tr>
<td>PDT</td>
<td><code>111111111</code></td>
<td>Index into the PDT</td>
</tr>
<tr>
<td>PT</td>
<td><code>111111111</code></td>
<td>Index into the PT</td>
</tr>
<tr>
<td>Offset</td>
<td><code>111111111111</code></td>
<td>Offset within the page</td>
</tr>
</tbody>
</table>
<p>This structure means that the processor uses these bits to navigate the multi-level page table hierarchy. The PML4 entry is used to locate the corresponding PDPT entry, and so on, until the final physical page is identified, and the <strong>offset</strong> is applied to access the specific data within the page.</p>
<h2 id="control-registers-for-paging">Control Registers for Paging</h2>
<p>On x86 and x86-64 architectures, control registers (specifically CR0, CR2, CR3, and CR4) play a crucial role in managing the paging system and overall memory management. These registers are used to configure how the processor handles virtual memory, paging, and other essential tasks related to memory protection and execution.</p>
<h3 id="cr0-register">CR0 Register</h3>
<p>The CR0 register controls several critical operating modes of the CPU, including enabling and disabling paging. Its relevant flags include:</p>
<ul>
<li>PG (Paging Enable): This flag controls whether paging is enabled or disabled. When set, the processor translates virtual addresses into physical addresses using the page tables.</li>
<li>PE (Protection Enable): This flag, when set, enables protected mode, which allows for the use of paging and access control based on privilege levels.</li>
<li>WP (Write Protect): This flag, when set, prevents supervisor-level code from writing to user-mode pages, providing an additional layer of memory protection.</li>
</ul>
<h3 id="cr2-register">CR2 Register</h3>
<p>The CR2 register holds the faulting address in the event of a page fault. When a page fault occurs (such as when a process tries to access a non-committed or non-existent page), the memory address that caused the fault is stored in CR2, allowing the operating system to handle the exception properly and decide how to proceed (e.g., by loading the page from disk or terminating the process).</p>
<h3 id="cr3-register">CR3 Register</h3>
<p>The CR3 register contains the physical address of the base of the page directory. This register is crucial in paging because it allows the CPU to locate the page tables needed for virtual address translation. The page directory is a top-level data structure that the memory management unit (MMU) uses to start the process of translating a virtual address into a physical address. The contents of CR3 are updated whenever a context switch occurs to change the address space of the running process.</p>
<p>In x86-64 systems, CR3 is responsible for pointing to the base of the PML4 (Page Map Level 4) table, which is the top level of the page table hierarchy.</p>
<h3 id="cr4-register">CR4 Register</h3>
<p>The CR4 register controls various advanced CPU features, many of which are related to memory management and protection mechanisms. Some of the relevant bits in CR4 include:</p>
<ul>
<li>PAE (Physical Address Extension): This flag enables 36-bit physical addressing, which allows for larger amounts of physical memory to be addressed than the standard 32-bit limit.</li>
<li>PSE (Page Size Extension): This flag allows the use of large pages (4 MB in x86, 2 MB or 1 GB in x86-64 systems), which can improve performance by reducing the overhead of managing smaller 4 KB pages.</li>
<li>SMEP (Supervisor Mode Execution Protection): This bit prevents supervisor-mode code (e.g., kernel code) from executing user-mode pages, which enhances security by reducing the risk of privilege escalation attacks.</li>
<li>NXE (No-Execute Enable): This flag enables support for the NX (No-Execute) bit in page tables, which marks pages as non-executable, preventing code execution from regions of memory not intended to contain executable code (such as the stack or heap).</li>
</ul>
<p>Together, these control registers form the backbone of paging and memory protection mechanisms in modern x86 and x86-64 systems. They ensure efficient and secure handling of memory by controlling how virtual addresses are translated, how exceptions are handled, and how memory protection is enforced.</p>
<h2 id="example-1-examining-virtual-and-physical-memory-using-windbg">Example 1: Examining virtual and physical memory using Windbg</h2>
<p>To practically work with addresses in kernel mode using Windbg on a Windows 10 virtual machine, the first step is to change the context to the desired process. Here’s a detailed step-by-step explanation:</p>
<h4 id="step-1-get-the-list-of-processes">Step 1: Get the List of Processes</h4>
<p>To begin, I attached to my Windows 10 VM via Windbg in kernel mode. To check the pages of a process in kernel mode, we first need to change the context to that process. Use the command <code>!process 0 0</code> to get a list of all processes running on the system.</p>
<table>
<thead>
<tr>
<th><center> <img src="Windbg-Processes.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 5: The processes list in windbg </b></center></td>
</tr>
</tbody>
</table>
<h4 id="step-2-change-context-to-a-specific-process">Step 2: Change Context to a Specific Process</h4>
<p>For this example, I am changing the context to cmd.exe. To do so, I need the address of the EPROCESS object for cmd.exe, which is ffffdd8291b29300. Then, I use the following command to change the context:
Windbg will prompt me to enter g to complete the context switch.</p>
<table>
<thead>
<tr>
<th><center> <img src="Windbg-ChangingContext.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 6: Changing process context in windbg </b></center></td>
</tr>
</tbody>
</table>
<h4 id="step-3-find-virtual-address-descriptors-vad">Step 3: Find Virtual Address Descriptors (VAD)</h4>
<p>Next, we need to find the page addresses. The !vad command provides details about the virtual address descriptors (VAD) of the process.</p>
<table>
<thead>
<tr>
<th><center> <img src="Windbg-VAD.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 7: Virtual Address Descriptors in windbg </b></center></td>
</tr>
</tbody>
</table>
<h4 id="step-4-retrieve-page-table-entry-pte">Step 4: Retrieve Page Table Entry (PTE)</h4>
<p>From the VAD list, I randomly select one address and use the <code>!pte</code> command to retrieve the page table entry. For instance:</p>
<table>
<thead>
<tr>
<th><center> <img src="Windbg-PTE.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 8: The Page Table entries </b></center></td>
</tr>
</tbody>
</table>
<h4 id="step-5-determine-plm4-and-cr3-values">Step 5: Determine PLM4 and CR3 Values</h4>
<p>To find the physical address for the page, we need the PLM4 address (FFFFEFF7FBFDFDD8) and the CR3 register value. The CR3 value is obtained by running:</p>
<pre tabindex="0"><code>r cr3
</code></pre><table>
<thead>
<tr>
<th><center> <img src="Windbg-cr3.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 9: The cr3 register value </b></center></td>
</tr>
</tbody>
</table>
<p>The CR3 value is 00000000ab994002. To convert this into a usable form, the first 12 bits should be set to zero, resulting in 00000000AB994000.</p>
<h4 id="step-6-convert-virtual-address-to-physical-address">Step 6: Convert Virtual Address to Physical Address</h4>
<p>Using the !vtop command, I can convert the virtual address to a physical address:</p>
<pre tabindex="0"><code>!vtop 00000000AB994000 FFFFEFF7FBFDFDD8
</code></pre><table>
<thead>
<tr>
<th><center> <img src="Windbg-vtop.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 10: Converting virtual address to the physical address using vtop command in windbg </b></center></td>
</tr>
</tbody>
</table>
<p>The output shows the translation of the virtual address FFFFEFF7FBFDFDD8 to the physical address ab994dd8.</p>
<h4 id="step-7-verify-using-physical-and-virtual-dump-commands">Step 7: Verify Using Physical and Virtual Dump Commands</h4>
<p>Finally, to verify the data in both the physical and virtual addresses, use the !dq command for the physical address:</p>
<pre tabindex="0"><code>!dq 00000000ab994dd8
</code></pre><p>And for the virtual address:</p>
<pre tabindex="0"><code>dq FFFFEFF7FBFDFDD8
</code></pre><p>Both commands will display the corresponding memory content:</p>
<table>
<thead>
<tr>
<th><center> <img src="Windbg-Physical-Virtual-Content.png" alt=""> </center></th>
</tr>
</thead>
<tbody>
<tr>
<td><center> <b>Figure 11: Comparing virtual memory and physical memory contents </b></center></td>
</tr>
</tbody>
</table>
<h2 id="example-2-finding-the-physical-address-of-a-page-using-the-pfn-formula-in-windows">Example 2: Finding the Physical Address of a Page Using the PFN Formula in Windows</h2>
<p>In the context of Windows memory management, PFN stands for <code>Page Frame Number</code>. It&rsquo;s an index that represents a page&rsquo;s location within physical memory, used by the memory manager to map virtual memory addresses to physical addresses. Each PFN points to a specific page in physical memory, helping the system to translate a virtual address into the actual physical address in RAM.</p>
<p>When dealing with page table entries in Windows, the PFN typically occupies a part of the PTE. For example, in a typical 4 KB page configuration, the PFN, combined with the page offset, helps calculate the exact physical address.</p>
<p>To translate a virtual address to a physical address using PFN, we can use the following formula:</p>
<pre tabindex="0"><code>Physical address = (PFN * Page_Size) + Offset
</code></pre><p>Let&rsquo;s examine how this applies with a sample C program that allocates memory at a specific virtual address:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LPVOID</span> <span class="n">lpAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x50000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">LPVOID</span> <span class="n">allocatedMemory</span> <span class="o">=</span> <span class="nf">VirtualAlloc</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">lpAddress</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="mi">4096</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">PAGE_READWRITE</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">allocatedMemory</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Memory allocation failed at 0x50000. Error: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">GetLastError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Memory successfully allocated at address: 0x%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">allocatedMemory</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">memset</span><span class="p">(</span><span class="n">allocatedMemory</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">allocatedMemory</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">VirtualFree</span><span class="p">(</span><span class="n">allocatedMemory</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Memory freed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This code allocates a 4KB page at virtual address <code>0x50000</code> and sets each byte to <code>0x7f</code>. After running this code, you can check the PTE for this address in WinDbg:</p>
<pre tabindex="0"><code>2: kd&gt; !pte 0x0000000000050000
                                           VA 0000000000050000
PXE at FFFFD8EC763B1000    PPE at FFFFD8EC76200000    PDE at FFFFD8EC40000000    PTE at FFFFD88000000280
contains 8A00000024489867  contains 0A0000011CCE4867  contains 0A00000114BE5867  contains 81000000360E6867
pfn 24489     ---DA--UW-V  pfn 11cce4    ---DA--UWEV  pfn 114be5    ---DA--UWEV  pfn 360e6     ---DA--UW-V
</code></pre><p>Here, the PFN for the page table entry (PTE) is <code>0x360e6</code>. Since each page is 4KB, we can calculate the physical address:</p>
<pre tabindex="0"><code>Physical Address = 0x360e6 * 0x1000 + 0 = 0x360e6000
</code></pre><p>To verify, use the dq command to view the contents at both the virtual and physical addresses:</p>
<pre tabindex="0"><code>2: kd&gt; dq 0x50000
00000000`00050000  7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
00000000`00050010  7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
00000000`00050020  7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
00000000`00050030  7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
00000000`00050040  7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
00000000`00050050  7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
00000000`00050060  7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
00000000`00050070  7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
2: kd&gt; !dq 0x360e6000
#360e6000 7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
#360e6010 7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
#360e6020 7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
#360e6030 7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
#360e6040 7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
#360e6050 7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
#360e6060 7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
#360e6070 7f7f7f7f`7f7f7f7f 7f7f7f7f`7f7f7f7f
</code></pre>
            </div>
        </article><hr style="margin-top: 40px; margin-bottom: 40px;" />
<div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "reodus" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></main>
</div>
<footer class="footer">
    <span class="footer_item"> </span>
    &nbsp;

    <div class="footer_social-icons">
<a href="https://github.com/reodus" target="_blank" rel="noopener noreferrer me"
    title="Github">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>
</a>
<a href="https://x.com/reodus_" target="_blank" rel="noopener noreferrer me"
    title="X">
    <svg viewBox="0 0 1200 1227" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6944H306.615L611.412 515.685L658.88 583.579L1055.08 1150.3H892.476L569.165 687.854V687.828Z"/>
</svg>
</a>
<a href="index.xml" target="_blank" rel="noopener noreferrer me"
    title="Rss">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 11a9 9 0 0 1 9 9" />
    <path d="M4 4a16 16 0 0 1 16 16" />
    <circle cx="5" cy="19" r="1" />
</svg>
</a>
</div>
    <small class="footer_copyright">
        © 2025 Reo.
        Powered by <a href="https://github.com/hugo-sid/hugo-blog-awesome" target="_blank" rel="noopener">Hugo blog awesome</a>.
    </small>
</footer><a href="#" title="Go to top" id="totop">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" stroke="currentColor" viewBox="0 96 960 960">
    <path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197Z"/>
</svg>

</a>


    




    
    
        
    

    
    
        
    



    
    <script src="https://reodus.com/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js" integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30&#43;lSNuSkl4QXuNyy8="></script>

    

</body>
</html>
